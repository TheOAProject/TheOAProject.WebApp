<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The OA Project</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">
</head>

<body>
   
    <div style="display: flex;flex-direction: column;">
<div class="block glow">
    <h1> The OA Project</h1>
</div>
    <div class="text-box">
        <div class="heading">To infinity and Beyond</div>
        <div class="button-wrapper">
            <div class="button" onclick="window.location.href='https://github.com';">Let's go to GitHub</div>
            <div class="button">Contact Us</div>
        </div>
    </div>
    </div>
    <!-- <canvas id="starField">
       
    </canvas> -->
    <!-- <div class="main"> </div> -->

        <!-- <div class="triangle glow"></div> -->
    
    <!--  -->
    <!-- <div>
        
    </div> -->
  
    <script>
        function randomNumber(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min
    }

    const STAR_COUNT = 100
    let result = ""
    for(let i = 0; i < STAR_COUNT; i++){
        result += `${randomNumber(-10, 10)}vw ${randomNumber(-10, 10)}vh ${randomNumber(0, 3)}px ${randomNumber(0, 3)}px #fff,`
    }
    console.log(result.substring(0, result.length - 1))
    // </script>
    // <script>
    //         const canvas = document.getElementById('starField');
    //         const c = canvas.getContext('2d');
    //         canvas.width = window.innerWidth; //screen width
    //         canvas.height = window.innerHeight; //screem height
    //         //on mouse scroll changes speed and color
    //         window.addEventListener('wheel', (event) => {
    //             c.strokeStyle = 'rgb(' + Math.random() * 255 + ', ' + Math.random() * 255 + ', ' + Math.random() * 255 + ')';
    //             if (event.deltaY < 0) speed *= 0.1;
    //             else speed *= 0.9;
    //             if (speed < 0.01) speed = 0.01; else if (speed > 0.1) speed = 0.1;
    //         });
    //         class Star {
    //             constructor() {
    //                 //initializing
    //                 this.x = Math.random() * canvas.width - canvas.width / 2;  //random x
    //                 this.y = Math.random() * canvas.height - canvas.height / 2; //random y
    //                 this.px, this.py;
    //                 this.z = Math.random() * 4; //random z    
    //             }

    //             update() {
    //                 //stores previous x, y and z and generates new coordinates    
    //                 this.px = this.x;
    //                 this.py = this.y;
    //                 this.z += speed;
    //                 this.x += this.x * (speed * 0.2) * this.z;
    //                 this.y += this.y * (speed * 0.2) * this.z;
    //                 if (this.x > canvas.width / 2 + 50 || this.x < -canvas.width / 2 - 50 || this.y > canvas.height / 2 + 50 || this.y < -canvas.height / 2 - 50) {
    //                     this.x = Math.random() * canvas.width - canvas.width / 2;
    //                     this.y = Math.random() * canvas.height - canvas.height / 2;
    //                     this.px = this.x;
    //                     this.py = this.y;
    //                     this.z = 0;
    //                 }
    //             }

    //             //draws line from x,y to px,py
    //             show() {
    //                 c.lineWidth = this.z;
    //                 c.beginPath();
    //                 c.moveTo(this.x, this.y);
    //                 c.lineTo(this.px, this.py);
    //                 c.stroke();
    //             }
    //         }
    //         let speed = 0.04;
    //         let stars = [];
    //         //create 1500 stars (objects)
    //         for (let i = 0; i < 1500; i++) stars.push(new Star());
    //         c.fillStyle = 'rgba(0, 0, 0, 0.1)';
    //         c.strokeStyle = 'rgb(' + Math.random() * 255 + ', ' + Math.random() * 255 + ', ' + Math.random() * 255 + ')';
    //         c.translate(canvas.width / 2, canvas.height / 2);
    //         function draw() {
    //             //create rectangle
    //             c.fillRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);
    //             for (let s of stars) {
    //                 s.update();
    //                 s.show();
    //             }
    //             //infinte call to draw
    //             requestAnimationFrame(draw);
    //         }
    //         draw();
    // </script>

    <script src="three.min.js"></script>
    <!-- <script>
        let scene, camera, renderer, stars, starGeo;

        function init() {

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 1;
            camera.rotation.x = Math.PI / 2;

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            starGeo = new THREE.Geometry();
            for (let i = 0; i < 6000; i++) {
                star = new THREE.Vector3(
                    Math.random() * 600 - 300,
                    Math.random() * 600 - 300,
                    Math.random() * 600 - 300
                );
                star.velocity = 0;
                star.acceleration = 0.02;
                starGeo.vertices.push(star);
            }

            let sprite = new THREE.TextureLoader().load('star.png');
            let starMaterial = new THREE.PointsMaterial({
                color: 0xaaaaaa,
                size: 0.7,
                map: sprite
            });

            stars = new THREE.Points(starGeo, starMaterial);
            scene.add(stars);

            window.addEventListener("resize", onWindowResize, false);

            animate();
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function animate() {
            starGeo.vertices.forEach(p => {
                p.velocity += p.acceleration
                p.y -= p.velocity;

                if (p.y < -200) {
                    p.y = 200;
                    p.velocity = 0;
                }
            });
            starGeo.verticesNeedUpdate = true;
            stars.rotation.y += 0.002;

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        init();

    </script> -->
</body>

</html>